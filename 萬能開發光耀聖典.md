# è¬èƒ½é–‹ç™¼å…‰è€€è–å…¸

## ğŸ“œ è–å…¸ç¸½ç¶±

æœ¬è–å…¸æ•´åˆ JunAiKey é …ç›®çš„æ‰€æœ‰é–‹ç™¼æ™ºæ…§ï¼Œæä¾›å®Œæ•´çš„é–‹ç™¼æŒ‡å°æ–¹é‡å’Œæœ€ä½³å¯¦è¸ã€‚

## ğŸ¯ æ ¸å¿ƒç†å¿µ

### 1. é›™èªè¨€é–‹ç™¼åŸå‰‡
- **å …æŒä½¿ç”¨ TypeScript** ä½œç‚ºä¸»è¦é–‹ç™¼èªè¨€
- **ç¹ä¸­è‹±ç¢¼çµ‚å§‹çŸ©é™£**ï¼šå§‹çµ‚ä¿æŒç¹é«”ä¸­æ–‡è¨»é‡‹å’Œè‹±æ–‡è®Šé‡åç¨±çš„å¹³è¡¡
- **ä»£ç¢¼å¯è®€æ€§**ï¼šç¢ºä¿ä»£ç¢¼æ—¢ç¬¦åˆæŠ€è¡“è¦ç¯„åˆå…·æœ‰æ–‡åŒ–å†…æ¶µ

### 2. AI æ¨¡å‹ä¸­ç«‹æ€§
- æ”¯æŒå¤šç¨® AI æ¨¡å‹æä¾›è€…ï¼ˆOpenAIã€Google Geminiã€Anthropic Claude ç­‰ï¼‰
- å¯¦ç¾æ¨¡å‹æŠ½è±¡å±¤ï¼Œä¾¿æ–¼å‹•æ…‹åˆ‡æ›
- é¼“å‹µæ¨¡å‹å‚™ä»½æ©Ÿåˆ¶ç¢ºä¿ç³»çµ±ç©©å®šæ€§

### 3. Markdown é–‹ç™¼ç’°å¢ƒ
- çµ±ä¸€çš„ Markdown è§£æå’ŒåµéŒ¯æ¡†æ¶
- å¯¦æ™‚é è¦½å’Œæ€§èƒ½ç›£æ§
- å®Œæ•´çš„æ¸¬è©¦å’Œéƒ¨ç½²æµç¨‹

## ğŸ“š é–‹ç™¼ç« ç¯€

### ç¬¬ä¸€ç« ï¼šTypeScript é–‹ç™¼è¦ç¯„

#### 1.1 åŸºæœ¬åŸå‰‡
```typescript
// âœ… æ­£ç¢ºç¤ºç¯„
class JunAiKeySystem {
  private readonly systemName: string;
  private readonly version: string;
  
  constructor(name: string, version: string) {
    this.systemName = name;
    this.version = version;
  }
  
  public getSystemInfo(): SystemInfo {
    return {
      name: this.systemName,
      version: this.version,
      timestamp: new Date()
    };
  }
}
```

#### 1.2 é¡å‹å®šç¾©è¦ç¯„
```typescript
// âœ… è¤‡åˆå‹åˆ¥å®šç¾©
export interface JunAiKeyConfig {
  readonly systemName: string;
  readonly version: string;
  readonly debugMode: boolean;
  readonly modelProvider: ModelProvider;
}

// âœ… åˆ—èˆ‰é¡å‹å®šç¾©
export enum ModelProvider {
  OPENAI = 'openai',
  GEMINI = 'gemini',
  CLAUDE = 'claude',
  CUSTOM = 'custom'
}
```

#### 1.3 éŒ¯èª¤è™•ç†è¦ç¯„
```typescript
// âœ… éŒ¯èª¤è™•ç†æ¨¡å¼
export class JunAiKeyError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly retryable: boolean;
  
  constructor(
    code: string,
    message: string,
    statusCode: number = 500,
    retryable: boolean = false
  ) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.retryable = retryable;
  }
}
```

### ç¬¬äºŒç« ï¼šAI æ¨¡å‹æ•´åˆ

#### 2.1 æ¨¡å‹æŠ½è±¡å±¤
```typescript
// âœ… æ¨¡å‹æŠ½è±¡æ¥å£
export interface IAIModel {
  generate(prompt: string): Promise<AIResponse>;
  fineTune(data: TrainingData[]): Promise<void>;
  getModelInfo(): ModelInfo;
}

// âœ… å…·é«”å¯¦ç¾
export class OpenAIModel implements IAIModel {
  private readonly apiKey: string;
  private readonly model: string;
  
  constructor(apiKey: string, model: string = 'gpt-4') {
    this.apiKey = apiKey;
    this.model = model;
  }
  
  public async generate(prompt: string): Promise<AIResponse> {
    // OpenAI API èª¿ç”¨å¯¦ç¾
  }
}
```

#### 2.2 æ¨¡å‹ç®¡ç†å™¨
```typescript
// âœ… æ¨¡å‹ç®¡ç†å™¨
export class ModelManager {
  private models: Map<string, IAIModel> = new Map();
  private defaultModel: string;
  
  public registerModel(name: string, model: IAIModel): void {
    this.models.set(name, model);
  }
  
  public getModel(name: string): IAIModel | null {
    return this.models.get(name) || null;
  }
  
  public switchModel(name: string): boolean {
    if (this.models.has(name)) {
      this.defaultModel = name;
      return true;
    }
    return false;
  }
}
```

### ç¬¬ä¸‰ç« ï¼šMarkdown é–‹ç™¼æ¡†æ¶

#### 3.1 Markdown è§£æå¼•æ“
```typescript
// âœ… Markdown å¼•æ“
export class MarkdownEngine {
  private parser: any;
  private debugger: MarkdownDebugger;
  
  constructor(options: MarkdownEngineOptions) {
    this.parser = this.createParser(options);
    this.debugger = new MarkdownDebugger();
  }
  
  public async parse(content: string): Promise<MarkdownDocument> {
    return this.debugger.wrapExecution(
      () => this.parser.parse(content),
      'markdown_parse'
    );
  }
}
```

#### 3.2 åµéŒ¯å·¥å…·çµ„
```typescript
// âœ… åµéŒ¯å™¨
export class MarkdownDebugger {
  private breakpoints: Map<string, DebugBreakpoint[]> = new Map();
  private logger: Logger;
  
  public setBreakpoint(file: string, line: number): void {
    this.breakpoints.set(file, [
      ...(this.breakpoints.get(file) || []),
      { line, enabled: true }
    ]);
  }
  
  public wrapExecution<T>(
    operation: () => Promise<T>,
    operationName: string
  ): Promise<T> {
    return this.logger.wrapAsync(
      operation,
      operationName,
      { enableDebug: true }
    );
  }
}
```

### ç¬¬å››ç« ï¼šç³»çµ±æ¶æ§‹è¨­è¨ˆ

#### 4.1 æ ¸å¿ƒç³»çµ±çµæ§‹
```typescript
// âœ… ç³»çµ±æ ¸å¿ƒ
export class JunAiKeyCore {
  private readonly config: JunAiKeyConfig;
  private readonly modelManager: ModelManager;
  private readonly markdownEngine: MarkdownEngine;
  private readonly errorMonitor: ErrorMonitor;
  
  constructor(config: JunAiKeyConfig) {
    this.config = config;
    this.modelManager = new ModelManager();
    this.markdownEngine = new MarkdownEngine(config.markdownOptions);
    this.errorMonitor = new ErrorMonitor();
  }
  
  public async initialize(): Promise<void> {
    await this.initializeModels();
    await this.initializeMarkdownEngine();
    this.setupErrorHandling();
  }
}
```

#### 4.2 äº‹ä»¶ç³»çµ±
```typescript
// âœ… äº‹ä»¶ç³»çµ±
export class EventBus {
  private events: Map<string, EventListener[]> = new Map();
  
  public on(event: string, listener: EventListener): void {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(listener);
  }
  
  public emit(event: string, data: any): void {
    const listeners = this.events.get(event) || [];
    listeners.forEach(listener => listener(data));
  }
}
```

## ğŸ”§ é–‹ç™¼å·¥å…·éˆ

### 1. é–‹ç™¼ç’°å¢ƒé…ç½®
```json
{
  "name": "junaikey-dev",
  "version": "1.0.0",
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "markdown:debug": "node --inspect-brk src/markdown/debugger.js"
  }
}
```

### 2. ä¾è³´åŒ…ç®¡ç†
```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.19.1",
    "typescript": "^5.3.3",
    "markdown-it": "^13.0.0",
    "unified": "^10.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.19.19",
    "jest": "^30.2.0",
    "ts-jest": "^29.4.4"
  }
}
```

### 3. é…ç½®æ–‡ä»¶
```typescript
// config/junaikey.config.ts
export const JUNAIKEY_CONFIG = {
  system: {
    name: "JunAiKey",
    version: "1.0.0",
    debug: process.env.NODE_ENV === "development"
  },
  models: {
    default: "openai",
    providers: {
      openai: { apiKey: process.env.OPENAI_API_KEY },
      gemini: { apiKey: process.env.GEMINI_API_KEY }
    }
  },
  markdown: {
    enableDebug: true,
    parserOptions: {
      breaks: true,
      gfm: true
    }
  }
};
```

## ğŸ§ª æ¸¬è©¦ç­–ç•¥

### 1. å–®å…ƒæ¸¬è©¦
```typescript
// tests/core/system.test.ts
describe('JunAiKeyCore', () => {
  test('should initialize successfully', async () => {
    const core = new JunAiKeyCore(TEST_CONFIG);
    await expect(core.initialize()).resolves.not.toThrow();
  });
});
```

### 2. é›†æˆæ¸¬è©¦
```typescript
// tests/integration/model.test.ts
describe('Model Integration', () => {
  test('should switch between models', async () => {
    const manager = new ModelManager();
    manager.registerModel('openai', new OpenAIModel('test'));
    manager.registerModel('gemini', new GeminiModel('test'));
    
    expect(manager.switchModel('gemini')).toBe(true);
    expect(manager.getModel('gemini')).toBeDefined();
  });
});
```

### 3. ç«¯åˆ°ç«¯æ¸¬è©¦
```typescript
// tests/e2e/markdown.test.ts
describe('Markdown E2E', () => {
  test('should parse complex markdown', async () => {
    const engine = new MarkdownEngine(TEST_MARKDOWN_CONFIG);
    const result = await engine.parse(COMPLEX_MARKDOWN);
    
    expect(result.type).toBe('document');
    expect(result.children).toHaveLength(5);
  });
});
```

## ğŸ“ˆ æ€§èƒ½ç›£æ§

### 1. æ€§èƒ½æŒ‡æ¨™
```typescript
// src/monitoring
