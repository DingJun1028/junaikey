# JunAiKey 代碼審查 Checklist

## 📋 代碼品質檢查

### 🔍 代碼規範
- [ ] 代碼格式符合 Prettier 配置
- [ ] 遵循 ESLint 規則，無警告或錯誤
- [ ] 使用一致的命名約定（駝峰命名法）
- [ ] 適當的代碼註釋和文檔
- [ ] 邏輯清晰，易於理解

### 🏗️ 架構設計
- [ ] 遵循專案的分層架構原則
- [ ] 職責分離，單一職責原則
- [ ] 依賴關係清晰，循環依賴已解決
- [ ] 接口定義清晰，符合接口隔離原則
- [ ] 適當的設計模式應用

### 🛡️ 安全性
- [ ] 輸入驗證完整
- [ ] 防止 SQL 注入和 XSS 攻擊
- [ ] 敏感數據已加密
- [ ] 實施最小權限原則
- [ ] 錯誤信息不暴露敏感信息

### ⚡ 性能
- [ ] 避免性能瓶頸
- [ ] 適當的緩存策略
- [ ] 資源正確釋放
- [ ] 非同步操作正確實現
- [ ] 數據庫查詢已優化

### 🧪 測試
- [ ] 單元測試覆蓋率高
- [ ] 集成測試完整
- [ ] 邊界情況已測試
- [ ] 錯誤處理已測試
- [ ] 測試代碼質量良好

## 📝 技術實現檢查

### TypeScript
- [ ] 啟用嚴格模式（strict: true）
- [ ] 無隱式 any 類型
- [ ] 適當的泛型使用
- [ ] 類型和接口定義清晰
- [ ] 錯誤處理使用類型安全的錯誤

### 錯誤處理
- [ ] 使用統一的錯誤處理機制
- [ ] 錯誤信息清晰明確
- [ ] 適當的錯誤級別（Error, Warn, Info）
- [ ] 錯誤追蹤信息完整
- [ ] 重試機制已實現

### 日誌記錄
- [ ] 結構化日誌記錄
- [ ] 適當的日誌級別
- [ ] 包含足夠的上下文信息
- [ ] 敏感信息已過濾
- [ ] 日誌格式統一

### 性能監控
- [ ] 關鍵操作有性能監控
- [ ] 適當的性能指標收集
- [ ] 性能閾值已設置
- [ ] 性能問題有警報機制
- [ ] 性能數據已分析

## 🔧 代碼審查流程

### 提交前檢查
- [ ] 本地測試通過
- [ ] 代碼格式化完成
- [ ] ESLint 檢查通過
- [ ] 測試覆蓋率符合要求
- [ ] 相關文檔已更新

### 審查過程
- [ ] 代碼邏輯正確性
- [ ] 性能影響評估
- [ ] 安全性風險評估
- [ ] 可維護性評估
- [ ] 測試完整性檢查

### 合併前確認
- [ ] 所有問題已解決
- [ ] 回饋已回應
- [ ] 代碼已最終審核
- [ ] 部署影響已評估
- [ ] 監控和警報已設置

## 📊 審查標準

### 品質等級
- **優秀 (A)**: 所有檢查項目通過，代碼質量卓越
- **良好 (B)**: 大部分檢查項目通過，少數 minor 問題
- **合格 (C)**: 基本通過，但有若干 major 問題需修正
- **不合格 (D)**: 存在嚴重問題，需重新修改

### 常見問題
1. **代碼重複**: 避免重複代碼，提取共用功能
2. **過長函數**: 函數長度控制在 50 行以內
3. **複雜條件**: 使用輔助函數簡化複雜條件判斷
4. **魔術數字**: 使用常量定義替換魔術數字
5. **硬編碼**: 避免硬編碼，使用配置管理

## 🎯 最佳實踐建議

### 代碼組織
- 保持模組化設計
- 使用清晰的文件結構
- 遵循單一職責原則
- 保持代碼 DRY (Don't Repeat Yourself)

### 性能優化
- 使用適當的數據結構
- 避免不必要的重複計算
- 實現延遲載入
- 優化 I/O 操作

### 安全性
- 實施輸入驗證
- 使用參數化查詢
- 實施訪問控制
- 定期安全審計

### 可維護性
- 編寫清晰的註釋
- 保持一致的編碼風格
- 實施完整的測試
- 建立良好的文檔
